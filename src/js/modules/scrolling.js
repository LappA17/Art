import calc from "./calc";

const scrolling = (upSelector) => {
    const upElem = document.querySelector(upSelector);
    window.addEventListener("scroll", () => {
        if (document.documentElement.scrollTop > 1650) {
/* scrollTop - то что мы уже не видим после пролистаного */
            
            upElem.classList.add('animated', "fadeIn");/* таким образом элемент через опесити который установлен
в css файле будет появляться на странице */
            upElem.classList.remove("fadeOut");/* теперь когда мы показываем элемент мы сразу добавляем класс который будет отвечать
 за скрытие элемента что бы в случае если мы будем мышкой туда сюда возить не было постоянно анимаций */
        } else {
            upElem.classList.add("fadeOut");//так элемент скроем
            upElem.classList.remove("fadeIn"); /* а здесь наоборот, когда мы элемент скрываем мы должны удалять класс который овтечает
за показ элемента */
        }/* ТЕПЕРЬ КОД ГОТОВ и когда мы пролистываем ниже 1650 пикселей у нас появляется справа та фигня для скрола
вверх что мы добавили с хтмл и она появляется сразу после 1650 пикселей и заходит обратно если пролистать выше 1650 */
    });

    // Реализация плавного скрола 

    const element = document.documentElement,
          body = document.body; 
    
    const calcScroll = () => {
        upElem.addEventListener("click", function(event) { /*upЕlem - элемент который мне прийдет 
кликнутый элемент это ССЫЛКА ПО ЭТОМУ НАМ ПОНАДОБИТСЯ ОБЪЕКТ СОБЫТИЕ ИВЕНТ что бы отменить стандартное поведение браузера*/

            let scrollTop = Math.round(body.scrollTop || element.scrollTop); /* то есть то что из этого body.scrollTop || element.scrollTop
будет существовать то и попадет в скрол топ, так мы обезопасем нас от багов
scrollTop в скролтоп помещаем сколько расстояние пролистано сверху */

            /* кроме того что браузер перезагружаетс из-за ссылку у нас так же появляется еще и хеш - это значит что если мы кликнем на ссылку
то у нас в домене покажет через # локальную ссылку */
            if (this.hash !== "") { // если хеш не пустой то я отменяю станд поведение браузера
                event.preventDefault();

                /* теперь получаем тот элемент к которому мы будем срколить нашу страницу */
                let hashElement = document.querySelector(this.hash),/*getElementById(this.hash.substring(1)), то есть мы от хеша получим строчку без решетки */
                    hashElementTop = 0;/*переменая которая будет показывать сколько еще нужно мне пролестать пикселей до родителя этого хешэлемента */

                while (hashElement.offsetParent) { /* offsetParent - обозначает свойство относительно которого будет позиционироваться
                     hashElement (те такой родитель его) */
                    hashElementTop += hashElement.offsetTop;/*offsetTop - позволяет определить а сколько пикселей осталось до верхней границы
родительского элемента, от хешэлемента */

                    /* теперь в цикле перебираем всех родителей которые могут быть основой для позициорнирования даного элемента */
                    hashElement = hashElement.offsetParent;
                }/* вот такой цикл который поможет перебрать всех родителей и узнать сколько пикселей нам нужно будет отлистать */

                hashElementTop = Math.round(hashElementTop);//округлим

                /* теперь мы знаем все значение что нам понадобятся для плавного скрола. Нам понадобиться scrollTop так как мы узнаем какое расстояние
было пролистано уже вниз пользователем. Нам понадобиться hashElementTop что бы знать сколько пикселей у нас уже отстоет от родительского элемента.
И так же нам понадобитсья this.hash что бы понимать к какому элементу мы все это листаем. Все эти три параметра мы поместим в фцию */
                smoothScroll(scrollTop, hashElementTop, this.hash);
            }
        }); 
    };

    const  smoothScroll = (from, to, hash) => { //откуда , куда, хеш
        let timeInterval = 1,//то значение через которое будет проходить анимация
            prevScrollTop,
            speed; //с какой скоростью будет анимация

        if (to > from) { //to - hashElementTop
            speed = 30; //скорость сверху вниз
        } else {
            speed = -30;
        }
        /*будет отвечать за анимацию */
        let move = setInterval(function(){
            let scrollTop = Math.round(body.scrollTop || element.scrollTop); /* ставим это в самое начало анимации потому что потому что когда
когда мы запускам calcScroll мы вычесляем впринципе самое первое значение(статично, которое не меняется), когда же у нас запускается анимация
то одно из этих значений будек каждый раз изменяться */

            if ( /* все эти условие в иф говорят что мы действительно долистали до того момента что нам было нужно */
                prevScrollTop === scrollTop || /* это значит что предыдущая анимация которая была воспризведена уже ровна тому что
мы хотели получить, те по русски это значит что нам уже некуда вращать эту страницу, мы достигли результата */

                (to > from && scrollTop >= to) ||
                (to < from && scrollTop <= to) 
            ) {
                clearInterval(move); // move это уникальный индиф который характеризует наш setInterval
                history.replaceState(history.state, document.title, location.href.replace(/#.*$/g, '') + hash);
/* поработаем с хистори для того что бы все востановить 
(/#.*$/g, '') - за счет этого регулярного выражение мы найдем все знаки шарпа в конце строки нашего href
hash - значение которое приходит в функцию smoothscroll и мы его получаем от this.hash*/

            } else {/*я хочу что бы моя страничка двигалась в нужном мне направление с той скоростью что мы задали */
                body.scrollTop += speed //теперь взависимости от знака моя страничка будет двигаться
                element.scrollTop += speed;
                prevScrollTop = scrollTop;/*мне нужно знать как изменятеся мое значение и я запишу в эту переменую скролтоп.
Те одна переменная которая пришла из фции from будет содержать статичное значение которое не меняется, вторая переменая которая называется
prevScrollTop и scrollTop тоже будет каждый раз перезаписываться в prevScrollTop = scrollTop; и теперь мы будем знать сколько нам еще
осталось пока мы долистаем до нужного нам момента */
            }
        }, timeInterval); // стоит значение 1
    };
    calcScroll();

    /* ВЕСЬ ЭТОТ ОГРОМНЫЙ КОД ЧТО БЫ ПРОСТО ПОСЛЕ НАЖАТИЯ НА СТРЕЛОЧКУ ПЛАВНО ВОЗВРАЩАЛО ВВЕРХ   */
};
export default scrolling;